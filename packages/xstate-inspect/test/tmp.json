export {
    inspect,
    createWindowReceiver,
    createWebSocketReceiver,
    createDevTools
  } from './browser';
  import { createDevTools, inspect } from '../src';
  import { readFileSync } from 'fs';
  import { interpret } from 'xstate';
  var Graph = require("graph-data-structure");
  
  
  const fullNameMaxLength = 10;
   
  export class RobustnessAnalysis {
    private _fullName: string = "";
   
    get fullName(): string {
      return this._fullName;
    }
   
    set fullName(newName: string) {
      if (newName && newName.length > fullNameMaxLength) {
        throw new Error("fullName has a max length of " + fullNameMaxLength);
      }
   
      this._fullName = newName;
    }
  
    test(){};
  }
  RobustnessAnalysis.prototype.test = function () {
    console.log("Engine is  :   ");
  };
  
  
  
  window.open = jest.fn();
  
  let tracePath = "";
  let traces = Array();
  let behaviorMachine;
  let propertyMachine;
  let iframeMockBSM;
  let iframeMockPSM;
  let serviceBSM;
  let servicePSM;
  let bsmPath;
  let psmPath;
  
  export function setTracePath(path) {
    tracePath = path;
    readTraces();
  }
  export function setModels(p1, p2) {
    bsmPath = p1;
    psmPath = p2;
  }
  
  const createiframeMockBSM = () => {
    const messages: any = [];
  
    // if only we wouldn't transpile down to es5 we could wrap this in a custom class extending EventTarget
    // transpiled classes can't extend native classes because they are calling super like this: var _this = _super.call(this) || this;
    // and native classes must be instantiated with new/super
    const iframe = new EventTarget() as HTMLIFrameElement;
  
    (iframe as any).contentWindow = {
      postMessage(ev) {
        messages.push(ev);
      }
    };
  
    iframe.setAttribute = () => {};
  
    return {
      iframe,
      initConnection() {
        iframe.dispatchEvent(new Event('load'));
        window.dispatchEvent(
          new MessageEvent('message', {
            data: {
              type: 'xstate.inspecting'
            }
          })
        );
      },
      flushMessages() {
        const [...flushed] = messages;
        messages.length = 0;
        return flushed;
      }
    };
  };
  
  export async function testInit(){
    const devTools = createDevTools();
  
    console.debug(bsmPath);
    const behaviorMachineModule = await import(bsmPath);
    behaviorMachine = behaviorMachineModule.behaviorMachine;
    serviceBSM = interpret(behaviorMachine, {
      devTools: true,
    }).start(); 
    iframeMockBSM = createiframeMockBSM();
    devTools.register(serviceBSM);
    inspect({iframe: iframeMockBSM.iframe,devTools,});
    iframeMockBSM.initConnection();
  
  
    const propertyMachineModule = await import(psmPath);
    propertyMachine = propertyMachineModule.propertyMachine;
    servicePSM = interpret(propertyMachine, {
      devTools: true,
    }).start();
    iframeMockPSM = createiframeMockBSM();
    devTools.register(servicePSM);
    inspect({iframe: iframeMockPSM.iframe,devTools,});
    iframeMockPSM.initConnection();
    
  
    //[0]. Get number of traces
    const numOfTraces = getNumOfTraces();
    console.debug(numOfTraces);
    //[1]. Read traces
    for (let x = 0; x < numOfTraces; x++){
      let trace = getTrace(0);
      replayBSM(iframeMockBSM, serviceBSM, trace);
      let result = replayPSM(iframeMockPSM, servicePSM, trace);  
      if (!result){
        console.debug("Majid Babaei");
        return;
      } 
    }
  
  
    
  
  }
  
  
  function readTraces() {
    const file = readFileSync(tracePath, 'utf-8');
    traces = file.split('\n');
    return traces;
  }
  
  function getNumOfTraces() {
    return traces.length;
  }
  
  function getTrace(index) {
    return traces[index];
  }
  
  function replayBSM(iframeMock, service, trace) {
    // Process trace into <event,message> structure
    const eventMsg = trace.split(",");
    const event = eventMsg[0];
    //console.debug(event);
  
    // TODO: msg need to be added
    service.send({ type: event });
    // Process the output from the interpreter to extract critical values
    let stt = "";
    iframeMock
      .flushMessages()
      .filter((message: any) => message.type === 'service.state')
      .filter((message: any) => stt = message.state);
      JSON.parse(stt);
      // console.debug(stateJSON);
      
      /*
      let stateJSON = JSON.parse(stt)
      // TODO: situations where might be more transitions should be handled
      console.debug(stateJSON.transitions[0].target);
      // TODO: extract variables from the configuration
      */
  }
  
  function replayPSM(iframeMock, service, trace) {
    // Process trace into <event,message> structure
    const eventMsg = trace.split(",");
    const event = eventMsg[0];
    //console.debug(event);
  
    // TODO: msg need to be added
    service.send({ type: event });
    // Process the output from the interpreter to extract critical values
    let stt = "";
    iframeMock
      .flushMessages()
      .filter((message: any) => message.type === 'service.state')
      .filter((message: any) => stt = message.state);
      let stateJSON = JSON.parse(stt);
      // console.debug(stateJSON);
      const psmTrg = stateJSON.value;
      if (psmTrg.indexOf("Bad") !== -1) {
        console.debug("HIT BAD STATE");
        // let OTCost = getCost(psmTrg);
        return false;
      }
      /*
      let stateJSON = JSON.parse(stt)
      // TODO: situations where might be more transitions should be handled
      console.debug(stateJSON.transitions[0].target);
      // TODO: extract variables from the configuration
      */
  }
  
  let visited = Array();
  var graphBSM = Graph();
  var graphPSM = Graph();
  
  //static analysis
  export function staticAnalysis() {
    
    const RCB = extractRC(propertyMachine, graphBSM);
    const RCP = extractRC(propertyMachine, graphPSM);
  
    console.debug(RCB);
    console.debug(RCP);
  }
  
  
  
  function extractRC(machine, graph) {
    const machineJSON = JSON.stringify(machine);
    const machineObject = JSON.parse(machineJSON);
  
    const initState = machineObject.initial;
    const id = machineObject.id;
  
    let RCs = Array({});
    visited.push(initState);
    const initStateOnJson = JSON.stringify(machineObject.states[initState].on);
    const initStateOnJsonParsed = JSON.parse(initStateOnJson);
    xstateCrawler(machineObject, initStateOnJsonParsed, RCs, id, graph);
  
    /*
    //showRC(RCs);
    var serialized = graph.serialize();
    console.debug(serialized);
    */
    return machineObject;
  }
  
  /*
  function showRC(RCs){
    for (let x = 0; x < RCs.length-1; x++){
      console.debug("rc[id]: "+  RCs[x].id);
      console.debug("rc[source]: "+  RCs[x].source);
      console.debug("rc[event]: "+  RCs[x].event);
      console.debug("rc[target]: "+  RCs[x].target);
    }
  }
  */
  
  
  
  function xstateCrawler(machineObject, initStateOnJsonParsed, RCs, id, graph) {
  
    let source, event, target;
    Object.keys(initStateOnJsonParsed).forEach(function (key) {
      source = initStateOnJsonParsed[key][0].source;
      event = initStateOnJsonParsed[key][0].event;
      target = initStateOnJsonParsed[key][0].target[0];
      const rc = { 'id': id, 'source': source, 'event': event, 'target': target };
      // console.debug(rc);
      RCs.push(rc);
  
      // console.debug(key + '=>source:' + initStateOnJsonParsed[key][0].source);
      // const trJson = JSON.stringify(initStateOnJsonParsed[key][0]);
      // console.log(key + "==> " + trJson);
      // console.log(key + "==> parsed: " + JSON.parse(JSON.stringify(initStateOnJsonParsed[key][0])));
    });
    if ((!visited.includes(target)) && (typeof (target) != 'undefined')) {
      graph.addEdge(source, target);
      visited.push(target);
      // console.debug('target: ' + target); 
      const targetArray = target.split('.');
      const targetOnJson = JSON.stringify(machineObject.states[targetArray[1]].on);
      const targetOnJsonParsed = JSON.parse(targetOnJson);
      xstateCrawler(machineObject, targetOnJsonParsed, RCs, id, graph);
    }
  }
  
  // //OT cost ← getCost(γP , rcb)
  // function getCost(psmTrg){
  
  // }
  
  // //BT cost ← computeBTCost(RCB , RCP , rcb, rcp, γB , γP )
  // function computeBTCost(){
  
  // }
  
  // export function raRun(){
  //   //[0]. Get number of traces
  //   const numOfTraces = getNumOfTraces();
  //   console.debug(numOfTraces);
  //   //[1]. Read traces
  //   for (let x = 0; x < numOfTraces; x++){
  //     let trace = getTrace(0);
  //     replayBSM(iframeMockBSM, serviceBSM, trace);
  //     let result = replayPSM(iframeMockPSM, servicePSM, trace);  
  //     if (!result){
  //       console.debug("Majid Babaei");
  //       return;
  //     } 
  //   }
  // }
  
  
  
    // for (state in machineObject.states) {
    //   if(state.key === initState) {
    //     console.debug("FOUND!");
    //   }
    // const initStateInfo = JSON.stringify(machineObject.initial[initState]);
    // console.debug(initState);
    // console.debug(initStateInfo);
  
  //getRCStepBSM (trace, msg, RCB ,γB)
  
  //getRCStepPSM (γ1.E, msg, RCP ,γP)
  
  // function xstateCrawler(machineObject){
  //   const initState = machineObject.initial;
  //   const initStateOnJson = JSON.stringify(machineObject.states[initState].on);
  //   const initStateOnJsonParsed = JSON.parse(initStateOnJson);
  //   console.debug("OUTPUT:",initStateOnJsonParsed);
  //   Object.keys(initStateOnJsonParsed).forEach(function(key){
  //     console.debug(key + '=>source:' + initStateOnJsonParsed[key][0].source);
  //     const trJson = JSON.stringify(initStateOnJsonParsed[key][0]);
  //     console.log(key + "==> " + trJson);
  //  });
  